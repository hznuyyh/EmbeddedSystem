; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o.\Obj\touchscreen_ads7843.o --depend=.\Obj\touchscreen_ads7843.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\User -I..\BaseDrive -I..\ExternalDrive\Lcd -I..\ExternalDrive\Fat_spi -IC:\Keil\ARM\INC -IC:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=.\Obj\touchscreen_ads7843.crf ..\User\TouchScreen_ADS7843.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  ADS7843_CS_config PROC
;;;18     
;;;19     void ADS7843_CS_config(void)
000000  b508              PUSH     {r3,lr}
;;;20     {
;;;21       GPIO_InitTypeDef GPIO_InitStructure;
;;;22       /* Enable GPIOB, GPIOC and AFIO clock */
;;;23       RCC_APB2PeriphClockCmd(RCC_ADS7843_CS , ENABLE);  //RCC_APB2Periph_AFIO
000002  2101              MOVS     r1,#1
000004  2008              MOVS     r0,#8
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;24       
;;;25       /* LEDs pins configuration */
;;;26       GPIO_InitStructure.GPIO_Pin = GPIO_ADS7843_CS;
00000a  f44f5080          MOV      r0,#0x1000
00000e  f8ad0000          STRH     r0,[sp,#0]
;;;27       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000012  2003              MOVS     r0,#3
000014  f88d0002          STRB     r0,[sp,#2]
;;;28       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000018  2010              MOVS     r0,#0x10
00001a  f88d0003          STRB     r0,[sp,#3]
;;;29       GPIO_Init(GPIO_ADS7843_CS_PORT, &GPIO_InitStructure);
00001e  4669              MOV      r1,sp
000020  48e2              LDR      r0,|L1.940|
000022  f7fffffe          BL       GPIO_Init
;;;30     }
000026  bd08              POP      {r3,pc}
;;;31     
                          ENDP

                  ADS7843_INT_config PROC
;;;32     static void ADS7843_INT_config(void)
000028  b508              PUSH     {r3,lr}
;;;33     {
;;;34       GPIO_InitTypeDef GPIO_InitStructure;
;;;35       /* Enable GPIOB, GPIOC and AFIO clock */
;;;36       RCC_APB2PeriphClockCmd(RCC_ADS7843_INT , ENABLE);  //RCC_APB2Periph_AFIO
00002a  2101              MOVS     r1,#1
00002c  0208              LSLS     r0,r1,#8
00002e  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;37       
;;;38       /* LEDs pins configuration */
;;;39       GPIO_InitStructure.GPIO_Pin = GPIO_ADS7843_INT;
000032  2080              MOVS     r0,#0x80
000034  f8ad0000          STRH     r0,[sp,#0]
;;;40       //GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;41       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
000038  2048              MOVS     r0,#0x48
00003a  f88d0003          STRB     r0,[sp,#3]
;;;42       GPIO_Init(GPIO_ADS7843_INT_PORT, &GPIO_InitStructure);
00003e  4669              MOV      r1,sp
000040  48db              LDR      r0,|L1.944|
000042  f7fffffe          BL       GPIO_Init
;;;43     }
000046  bd08              POP      {r3,pc}
;;;44     
                          ENDP

                  ADS7843_INT_EXIT_Init PROC
;;;45     static void ADS7843_INT_EXIT_Init(void)
000048  b51c              PUSH     {r2-r4,lr}
;;;46     {
;;;47         EXTI_InitTypeDef EXTI_InitStructure;
;;;48     
;;;49         /* Connect Button EXTI Line to Button GPIO Pin */
;;;50         GPIO_EXTILineConfig(GPIO_ADS7843_EXTI_PORT_SOURCE, GPIO_ADS7843_EXTI_PIN_SOURCE);  
00004a  2107              MOVS     r1,#7
00004c  2006              MOVS     r0,#6
00004e  f7fffffe          BL       GPIO_EXTILineConfig
;;;51     
;;;52         /* Configure Button EXTI line */
;;;53         EXTI_InitStructure.EXTI_Line = GPIO_ADS7843_EXTI_LINE;
000052  2080              MOVS     r0,#0x80
000054  9000              STR      r0,[sp,#0]
;;;54         EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
000056  2000              MOVS     r0,#0
000058  f88d0004          STRB     r0,[sp,#4]
;;;55         EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;  
00005c  200c              MOVS     r0,#0xc
00005e  f88d0005          STRB     r0,[sp,#5]
;;;56         EXTI_InitStructure.EXTI_LineCmd = ENABLE;
000062  2001              MOVS     r0,#1
000064  f88d0006          STRB     r0,[sp,#6]
;;;57         EXTI_Init(&EXTI_InitStructure);
000068  4668              MOV      r0,sp
00006a  f7fffffe          BL       EXTI_Init
;;;58     
;;;59     }
00006e  bd1c              POP      {r2-r4,pc}
;;;60     
                          ENDP

                  ADS7843_InterruptConfig PROC
;;;68     *******************************************************************************/
;;;69     static void ADS7843_InterruptConfig(void)
000070  b508              PUSH     {r3,lr}
;;;70     { 
;;;71       NVIC_InitTypeDef NVIC_InitStructure;
;;;72       
;;;73       /* Set the Vector Table base address at 0x08000000 */
;;;74       NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0000);
000072  2100              MOVS     r1,#0
000074  f04f6000          MOV      r0,#0x8000000
000078  f7fffffe          BL       NVIC_SetVectorTable
;;;75       
;;;76       /* Configure the Priority Group to 2 bits */
;;;77       NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
00007c  f44f60a0          MOV      r0,#0x500
000080  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;78     
;;;79       /* Enable the EXTI5 Interrupt */
;;;80       NVIC_InitStructure.NVIC_IRQChannel = GPIO_ADS7843_EXTI_IRQn;
000084  2017              MOVS     r0,#0x17
000086  f88d0000          STRB     r0,[sp,#0]
;;;81       NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
00008a  2000              MOVS     r0,#0
00008c  f88d0001          STRB     r0,[sp,#1]
;;;82       NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000090  f88d0002          STRB     r0,[sp,#2]
;;;83       NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000094  2001              MOVS     r0,#1
000096  f88d0003          STRB     r0,[sp,#3]
;;;84       NVIC_Init(&NVIC_InitStructure);
00009a  4668              MOV      r0,sp
00009c  f7fffffe          BL       NVIC_Init
;;;85     }
0000a0  bd08              POP      {r3,pc}
;;;86     
                          ENDP

                  _AD2X PROC
;;;90     /*=====================================================================*/
;;;91     u16 _AD2X(u16 adx) //240
0000a2  4603              MOV      r3,r0
;;;92     {
;;;93       u16 sx=0;
0000a4  bf00              NOP      
;;;94       int r = adx - 200;
0000a6  f1a302c8          SUB      r2,r3,#0xc8
;;;95       r *= 240;
0000aa  ebc21002          RSB      r0,r2,r2,LSL #4
0000ae  0102              LSLS     r2,r0,#4
;;;96       sx=r / (4000 - 280);
0000b0  f6406088          MOV      r0,#0xe88
0000b4  fb92f0f0          SDIV     r0,r2,r0
0000b8  b281              UXTH     r1,r0
;;;97       if (sx<=0 || sx>240)
0000ba  2900              CMP      r1,#0
0000bc  dd01              BLE      |L1.194|
0000be  29f0              CMP      r1,#0xf0
0000c0  dd01              BLE      |L1.198|
                  |L1.194|
;;;98         return 0;
0000c2  2000              MOVS     r0,#0
                  |L1.196|
;;;99       return sx;
;;;100    }
0000c4  4770              BX       lr
                  |L1.198|
0000c6  4608              MOV      r0,r1                 ;99
0000c8  e7fc              B        |L1.196|
;;;101    
                          ENDP

                  _AD2Y PROC
;;;102    
;;;103    u16 _AD2Y(u16 ady) //320
0000ca  4603              MOV      r3,r0
;;;104    {
;;;105      u16 sy=0;
0000cc  bf00              NOP      
;;;106      int r = ady - 260;
0000ce  f5a37282          SUB      r2,r3,#0x104
;;;107      r *= 320;
0000d2  eb020082          ADD      r0,r2,r2,LSL #2
0000d6  0182              LSLS     r2,r0,#6
;;;108      sy=r/(3960 - 360);
0000d8  f44f6061          MOV      r0,#0xe10
0000dc  fb92f0f0          SDIV     r0,r2,r0
0000e0  b281              UXTH     r1,r0
;;;109      if (sy<=0 || sy>320)
0000e2  2900              CMP      r1,#0
0000e4  dd02              BLE      |L1.236|
0000e6  f5b17fa0          CMP      r1,#0x140
0000ea  dd01              BLE      |L1.240|
                  |L1.236|
;;;110        return 0;
0000ec  2000              MOVS     r0,#0
                  |L1.238|
;;;111      return sy;
;;;112    }
0000ee  4770              BX       lr
                  |L1.240|
0000f0  4608              MOV      r0,r1                 ;111
0000f2  e7fc              B        |L1.238|
;;;113    
                          ENDP

                  SPI1_Init_For_Byte PROC
;;;167    /*=====================================================================*/
;;;168    void SPI1_Init_For_Byte(void)
0000f4  4770              BX       lr
;;;169    {
;;;170    
;;;171    }
;;;172    
                          ENDP

                  SPI1_Config PROC
;;;146    
;;;147    void SPI1_Config(void)
0000f6  b508              PUSH     {r3,lr}
;;;148    {
;;;149      GPIO_InitTypeDef GPIO_InitStructure;
;;;150        
;;;151      // Set as Output push-pull - SCK and MOSI
;;;152      RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
0000f8  2101              MOVS     r1,#1
0000fa  2004              MOVS     r0,#4
0000fc  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;153      
;;;154      GPIO_InitStructure.GPIO_Pin = SPI1_SCK | SPI1_MOSI;
000100  f44f4020          MOV      r0,#0xa000
000104  f8ad0000          STRH     r0,[sp,#0]
;;;155      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000108  2003              MOVS     r0,#3
00010a  f88d0002          STRB     r0,[sp,#2]
;;;156      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
00010e  2010              MOVS     r0,#0x10
000110  f88d0003          STRB     r0,[sp,#3]
;;;157      GPIO_Init(SPI1_PORT, &GPIO_InitStructure);
000114  4669              MOV      r1,sp
000116  48a5              LDR      r0,|L1.940|
000118  f7fffffe          BL       GPIO_Init
;;;158      
;;;159      //SPI_MISO
;;;160      GPIO_InitStructure.GPIO_Pin = SPI1_MISO;
00011c  f44f4080          MOV      r0,#0x4000
000120  f8ad0000          STRH     r0,[sp,#0]
;;;161      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000124  2003              MOVS     r0,#3
000126  f88d0002          STRB     r0,[sp,#2]
;;;162      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
00012a  2048              MOVS     r0,#0x48
00012c  f88d0003          STRB     r0,[sp,#3]
;;;163      GPIO_Init(SPI1_PORT, &GPIO_InitStructure);
000130  4669              MOV      r1,sp
000132  489e              LDR      r0,|L1.940|
000134  f7fffffe          BL       GPIO_Init
;;;164    
;;;165    }
000138  bd08              POP      {r3,pc}
;;;166    
                          ENDP

                  ADS7843_Init PROC
;;;127    
;;;128    void ADS7843_Init(void)
00013a  b510              PUSH     {r4,lr}
;;;129    {
;;;130        ADS7843_CS_config();     // 使能LCD
00013c  f7fffffe          BL       ADS7843_CS_config
;;;131        ADS7843_CS_HIGH() ;     // 关闭LCD
000140  2108              MOVS     r1,#8
000142  489a              LDR      r0,|L1.940|
000144  f7fffffe          BL       GPIO_SetBits
;;;132        SPI1_Config();
000148  f7fffffe          BL       SPI1_Config
;;;133        SPI1_Init_For_Byte();
00014c  f7fffffe          BL       SPI1_Init_For_Byte
;;;134        SPI1_MOSI_HIGH();
000150  f44f4100          MOV      r1,#0x8000
000154  4895              LDR      r0,|L1.940|
000156  f7fffffe          BL       GPIO_SetBits
;;;135        SPI1_SCK_LOW();
00015a  f44f5100          MOV      r1,#0x2000
00015e  4893              LDR      r0,|L1.940|
000160  f7fffffe          BL       GPIO_ResetBits
;;;136        ADS7843_INT_config();
000164  f7fffffe          BL       ADS7843_INT_config
;;;137        ADS7843_INT_EXIT_Init();
000168  f7fffffe          BL       ADS7843_INT_EXIT_Init
;;;138        ADS7843_InterruptConfig();
00016c  f7fffffe          BL       ADS7843_InterruptConfig
;;;139    	touchPoint.x =0;
000170  2000              MOVS     r0,#0
000172  4990              LDR      r1,|L1.948|
000174  6008              STR      r0,[r1,#0]  ; touchPoint
;;;140    	touchPoint.y =0;
000176  6048              STR      r0,[r1,#4]  ; touchPoint
;;;141    	touchPoint.flag =0;
000178  7208              STRB     r0,[r1,#8]
;;;142    }
00017a  bd10              POP      {r4,pc}
;;;143    /*=====================================================================*/
                          ENDP

                  ADS7843_SPI_Start PROC
;;;173    /*=====================================================================*/
;;;174    static void ADS7843_SPI_Start( void )
00017c  b510              PUSH     {r4,lr}
;;;175    {
;;;176        ADS7843_CS_HIGH();
00017e  2108              MOVS     r1,#8
000180  488a              LDR      r0,|L1.940|
000182  f7fffffe          BL       GPIO_SetBits
;;;177        SPI1_MOSI_HIGH();
000186  f44f4100          MOV      r1,#0x8000
00018a  4888              LDR      r0,|L1.940|
00018c  f7fffffe          BL       GPIO_SetBits
;;;178        SPI1_SCK_LOW();
000190  f44f5100          MOV      r1,#0x2000
000194  4885              LDR      r0,|L1.940|
000196  f7fffffe          BL       GPIO_ResetBits
;;;179        ADS7843_CS_LOW();	      		//芯片允许
00019a  2108              MOVS     r1,#8
00019c  4883              LDR      r0,|L1.940|
00019e  f7fffffe          BL       GPIO_ResetBits
;;;180    }
0001a2  bd10              POP      {r4,pc}
;;;181    
                          ENDP

                  SPI_MOSI PROC
;;;182    /*=====================================================================*/
;;;183    static void SPI_MOSI(u8 data)
0001a4  b510              PUSH     {r4,lr}
;;;184    {
0001a6  4604              MOV      r4,r0
;;;185        if(data)
0001a8  b12c              CBZ      r4,|L1.438|
;;;186            SPI1_MOSI_HIGH();
0001aa  f44f4100          MOV      r1,#0x8000
0001ae  487f              LDR      r0,|L1.940|
0001b0  f7fffffe          BL       GPIO_SetBits
0001b4  e004              B        |L1.448|
                  |L1.438|
;;;187        else
;;;188            SPI1_MOSI_LOW();
0001b6  f44f4100          MOV      r1,#0x8000
0001ba  487c              LDR      r0,|L1.940|
0001bc  f7fffffe          BL       GPIO_ResetBits
                  |L1.448|
;;;189    }
0001c0  bd10              POP      {r4,pc}
;;;190    
                          ENDP

                  ADS7843_WrCmd PROC
;;;205    /*=====================================================================*/
;;;206    static void ADS7843_WrCmd(u8 cmd)
0001c2  b570              PUSH     {r4-r6,lr}
;;;207    {
0001c4  4606              MOV      r6,r0
;;;208        u8 buf, i;
;;;209    
;;;210        for( i = 0; i < 8; i++ )
0001c6  2500              MOVS     r5,#0
0001c8  e014              B        |L1.500|
                  |L1.458|
;;;211        {
;;;212            buf = (cmd >> (7-i)) & 0x1 ;	//MSB在前,LSB在后
0001ca  f1c50007          RSB      r0,r5,#7
0001ce  fa46f000          ASR      r0,r6,r0
0001d2  f0000401          AND      r4,r0,#1
;;;213            SPI_MOSI(buf);	 	//时钟上升沿锁存DIN
0001d6  4620              MOV      r0,r4
0001d8  f7fffffe          BL       SPI_MOSI
;;;214            SPI1_SCK_HIGH();			//时钟脉冲，一共8个
0001dc  f44f5100          MOV      r1,#0x2000
0001e0  4872              LDR      r0,|L1.940|
0001e2  f7fffffe          BL       GPIO_SetBits
;;;215            SPI1_SCK_LOW();			//开始发送命令字
0001e6  f44f5100          MOV      r1,#0x2000
0001ea  4870              LDR      r0,|L1.940|
0001ec  f7fffffe          BL       GPIO_ResetBits
0001f0  1c68              ADDS     r0,r5,#1              ;210
0001f2  b2c5              UXTB     r5,r0                 ;210
                  |L1.500|
0001f4  2d08              CMP      r5,#8                 ;210
0001f6  dbe8              BLT      |L1.458|
;;;216        }
;;;217    	
;;;218    }
0001f8  bd70              POP      {r4-r6,pc}
;;;219    
                          ENDP

                  ADS7843_Read PROC
;;;220    /*=====================================================================*/
;;;221    static u16 ADS7843_Read(void)
0001fa  b570              PUSH     {r4-r6,lr}
;;;222    {
;;;223    	u16 buf = 0 ;
0001fc  2500              MOVS     r5,#0
;;;224    	u8 i;
;;;225    
;;;226        SPI1_SCK_HIGH(); //wait busy
0001fe  f44f5100          MOV      r1,#0x2000
000202  486a              LDR      r0,|L1.940|
000204  f7fffffe          BL       GPIO_SetBits
;;;227    	SPI1_SCK_LOW();	
000208  f44f5100          MOV      r1,#0x2000
00020c  4867              LDR      r0,|L1.940|
00020e  f7fffffe          BL       GPIO_ResetBits
;;;228    	for( i = 0; i < 12; i++ )
000212  2400              MOVS     r4,#0
000214  e015              B        |L1.578|
                  |L1.534|
;;;229    	{
;;;230    		buf = buf << 1 ;
000216  0468              LSLS     r0,r5,#17
000218  0c05              LSRS     r5,r0,#16
;;;231    		SPI1_SCK_HIGH();
00021a  f44f5100          MOV      r1,#0x2000
00021e  4863              LDR      r0,|L1.940|
000220  f7fffffe          BL       GPIO_SetBits
;;;232    		if ( SPI1_MISO_READ() )	
000224  f44f4180          MOV      r1,#0x4000
000228  4860              LDR      r0,|L1.940|
00022a  f7fffffe          BL       GPIO_ReadInputDataBit
00022e  b108              CBZ      r0,|L1.564|
;;;233    		{
;;;234    			buf = buf + 1 ;
000230  1c68              ADDS     r0,r5,#1
000232  b285              UXTH     r5,r0
                  |L1.564|
;;;235    		}
;;;236    		SPI1_SCK_LOW();			
000234  f44f5100          MOV      r1,#0x2000
000238  485c              LDR      r0,|L1.940|
00023a  f7fffffe          BL       GPIO_ResetBits
00023e  1c60              ADDS     r0,r4,#1              ;228
000240  b2c4              UXTB     r4,r0                 ;228
                  |L1.578|
000242  2c0c              CMP      r4,#0xc               ;228
000244  dbe7              BLT      |L1.534|
;;;237    	}
;;;238    
;;;239    	for( i = 0; i < 3; i++ )
000246  2400              MOVS     r4,#0
000248  e00b              B        |L1.610|
                  |L1.586|
;;;240    	{
;;;241    		SPI1_SCK_HIGH();
00024a  f44f5100          MOV      r1,#0x2000
00024e  4857              LDR      r0,|L1.940|
000250  f7fffffe          BL       GPIO_SetBits
;;;242    		SPI1_SCK_LOW();			
000254  f44f5100          MOV      r1,#0x2000
000258  4854              LDR      r0,|L1.940|
00025a  f7fffffe          BL       GPIO_ResetBits
00025e  1c60              ADDS     r0,r4,#1              ;239
000260  b2c4              UXTB     r4,r0                 ;239
                  |L1.610|
000262  2c03              CMP      r4,#3                 ;239
000264  dbf1              BLT      |L1.586|
;;;243    	}
;;;244        
;;;245    	return( buf ) ;
000266  4628              MOV      r0,r5
;;;246    }
000268  bd70              POP      {r4-r6,pc}
;;;247    
                          ENDP

                  ADS7843_Rd_Addata PROC
;;;249    #define  times  4
;;;250    static void ADS7843_Rd_Addata(u16 *X_Addata,u16 *Y_Addata)
00026a  e92d41ff          PUSH     {r0-r8,lr}
;;;251    {
00026e  4607              MOV      r7,r0
000270  4688              MOV      r8,r1
;;;252    
;;;253    	u16		i,j,k,x_addata[times],y_addata[times];
;;;254            
;;;255    	for(i=0;i<times;i++)					//采样4次.
000272  2400              MOVS     r4,#0
000274  e01c              B        |L1.688|
                  |L1.630|
;;;256    	{
;;;257    	    ADS7843_SPI_Start();
000276  f7fffffe          BL       ADS7843_SPI_Start
;;;258    		ADS7843_WrCmd( CHX ) ;
00027a  2090              MOVS     r0,#0x90
00027c  f7fffffe          BL       ADS7843_WrCmd
;;;259    		y_addata[i] = ADS7843_Read() ;
000280  f7fffffe          BL       ADS7843_Read
000284  f82d0014          STRH     r0,[sp,r4,LSL #1]
;;;260            ADS7843_CS_HIGH(); 
000288  2108              MOVS     r1,#8
00028a  4848              LDR      r0,|L1.940|
00028c  f7fffffe          BL       GPIO_SetBits
;;;261    
;;;262    	    ADS7843_SPI_Start();
000290  f7fffffe          BL       ADS7843_SPI_Start
;;;263    		ADS7843_WrCmd( CHY ) ;
000294  20d0              MOVS     r0,#0xd0
000296  f7fffffe          BL       ADS7843_WrCmd
;;;264    		x_addata[i] = ADS7843_Read() ;
00029a  f7fffffe          BL       ADS7843_Read
00029e  a902              ADD      r1,sp,#8
0002a0  f8210014          STRH     r0,[r1,r4,LSL #1]
;;;265            ADS7843_CS_HIGH(); 
0002a4  2108              MOVS     r1,#8
0002a6  4841              LDR      r0,|L1.940|
0002a8  f7fffffe          BL       GPIO_SetBits
0002ac  1c60              ADDS     r0,r4,#1              ;255
0002ae  b284              UXTH     r4,r0                 ;255
                  |L1.688|
0002b0  2c04              CMP      r4,#4                 ;255
0002b2  dbe0              BLT      |L1.630|
;;;266    	}
;;;267    
;;;268    	for(i=0;i<times;i++)
0002b4  2400              MOVS     r4,#0
0002b6  e01a              B        |L1.750|
                  |L1.696|
;;;269    	{
;;;270        	for(j=times;j<times-1;j++)
0002b8  2504              MOVS     r5,#4
0002ba  e014              B        |L1.742|
                  |L1.700|
;;;271        	{
;;;272               if(x_addata[j] > x_addata[i])
0002bc  a802              ADD      r0,sp,#8
0002be  f8300015          LDRH     r0,[r0,r5,LSL #1]
0002c2  a902              ADD      r1,sp,#8
0002c4  f8311014          LDRH     r1,[r1,r4,LSL #1]
0002c8  4288              CMP      r0,r1
0002ca  dd0a              BLE      |L1.738|
;;;273                {
;;;274                    k = x_addata[j];
0002cc  a802              ADD      r0,sp,#8
0002ce  f8306015          LDRH     r6,[r0,r5,LSL #1]
;;;275                    x_addata[i] = x_addata[j];
0002d2  f8300015          LDRH     r0,[r0,r5,LSL #1]
0002d6  a902              ADD      r1,sp,#8
0002d8  f8210014          STRH     r0,[r1,r4,LSL #1]
;;;276                    x_addata[j] = k;
0002dc  a802              ADD      r0,sp,#8
0002de  f8206015          STRH     r6,[r0,r5,LSL #1]
                  |L1.738|
0002e2  1c68              ADDS     r0,r5,#1              ;270
0002e4  b285              UXTH     r5,r0                 ;270
                  |L1.742|
0002e6  2d03              CMP      r5,#3                 ;270
0002e8  dbe8              BLT      |L1.700|
0002ea  1c60              ADDS     r0,r4,#1              ;268
0002ec  b284              UXTH     r4,r0                 ;268
                  |L1.750|
0002ee  2c04              CMP      r4,#4                 ;268
0002f0  dbe2              BLT      |L1.696|
;;;277                }
;;;278             }
;;;279        }
;;;280    
;;;281    	for(i=0;i<times;i++)
0002f2  2400              MOVS     r4,#0
0002f4  e015              B        |L1.802|
                  |L1.758|
;;;282    	{
;;;283        	for(j=times;j<times-1;j++)
0002f6  2504              MOVS     r5,#4
0002f8  e00f              B        |L1.794|
                  |L1.762|
;;;284        	{
;;;285               if(y_addata[j] > y_addata[i])
0002fa  f83d0015          LDRH     r0,[sp,r5,LSL #1]
0002fe  f83d1014          LDRH     r1,[sp,r4,LSL #1]
000302  4288              CMP      r0,r1
000304  dd07              BLE      |L1.790|
;;;286                {
;;;287                    k = y_addata[j];
000306  f83d6015          LDRH     r6,[sp,r5,LSL #1]
;;;288                    y_addata[i] = y_addata[j];
00030a  f83d0015          LDRH     r0,[sp,r5,LSL #1]
00030e  f82d0014          STRH     r0,[sp,r4,LSL #1]
;;;289                    y_addata[j] = k;
000312  f82d6015          STRH     r6,[sp,r5,LSL #1]
                  |L1.790|
000316  1c68              ADDS     r0,r5,#1              ;283
000318  b285              UXTH     r5,r0                 ;283
                  |L1.794|
00031a  2d03              CMP      r5,#3                 ;283
00031c  dbed              BLT      |L1.762|
00031e  1c60              ADDS     r0,r4,#1              ;281
000320  b284              UXTH     r4,r0                 ;281
                  |L1.802|
000322  2c04              CMP      r4,#4                 ;281
000324  dbe7              BLT      |L1.758|
;;;290                }
;;;291             }
;;;292        }
;;;293    		
;;;294    	*X_Addata=(x_addata[1] + x_addata[2]) >> 1;
000326  f8bd000a          LDRH     r0,[sp,#0xa]
00032a  f8bd100c          LDRH     r1,[sp,#0xc]
00032e  4408              ADD      r0,r0,r1
000330  1040              ASRS     r0,r0,#1
000332  8038              STRH     r0,[r7,#0]
;;;295    	*Y_Addata= 4095 - ((y_addata[1] + y_addata[2]) >> 1);
000334  f8bd0002          LDRH     r0,[sp,#2]
000338  f8bd1004          LDRH     r1,[sp,#4]
00033c  4408              ADD      r0,r0,r1
00033e  f64071ff          MOV      r1,#0xfff
000342  eba10060          SUB      r0,r1,r0,ASR #1
000346  f8a80000          STRH     r0,[r8,#0]
;;;296    
;;;297    }
00034a  e8bd81ff          POP      {r0-r8,pc}
;;;298    
                          ENDP

                  distence PROC
;;;301    /*=====================================================================*/
;;;302    u16 distence(u16 data1,u16 data2)
00034e  4602              MOV      r2,r0
;;;303    {
;;;304        if(data1 > data2 + 10)
000350  f101000a          ADD      r0,r1,#0xa
000354  4282              CMP      r2,r0
000356  dd01              BLE      |L1.860|
;;;305        {
;;;306            return 0;
000358  2000              MOVS     r0,#0
                  |L1.858|
;;;307        }
;;;308    
;;;309        if(data2 > data1 + 10)
;;;310        {
;;;311            return 0;
;;;312        }
;;;313    
;;;314        return 1;    
;;;315    }
00035a  4770              BX       lr
                  |L1.860|
00035c  f102000a          ADD      r0,r2,#0xa            ;309
000360  4281              CMP      r1,r0                 ;309
000362  dd01              BLE      |L1.872|
000364  2000              MOVS     r0,#0                 ;311
000366  e7f8              B        |L1.858|
                  |L1.872|
000368  2001              MOVS     r0,#1                 ;314
00036a  e7f6              B        |L1.858|
;;;316    
                          ENDP

                  TouchScreen_ADS7843 PROC
;;;317    /*=====================================================================*/
;;;318    void TouchScreen_ADS7843(void)
00036c  b57c              PUSH     {r2-r6,lr}
;;;319    {
;;;320      u16 xdata, ydata;
;;;321      u32 xScreen, yScreen;
;;;322     // static int sDataX,sDataY;
;;;323      ADS7843_Rd_Addata(&xdata, &ydata);
00036e  4669              MOV      r1,sp
000370  a801              ADD      r0,sp,#4
000372  f7fffffe          BL       ADS7843_Rd_Addata
;;;324      xScreen = _AD2X(xdata);
000376  f8bd0004          LDRH     r0,[sp,#4]
00037a  f7fffffe          BL       _AD2X
00037e  4604              MOV      r4,r0
;;;325      yScreen = _AD2Y(ydata);
000380  f8bd0000          LDRH     r0,[sp,#0]
000384  f7fffffe          BL       _AD2Y
000388  4605              MOV      r5,r0
;;;326      if((xScreen>1)&&(yScreen>1)&&(xScreen<240-1)&&(yScreen<320-1))
00038a  2c01              CMP      r4,#1
00038c  d90c              BLS      |L1.936|
00038e  2d01              CMP      r5,#1
000390  d90a              BLS      |L1.936|
000392  2cef              CMP      r4,#0xef
000394  d208              BCS      |L1.936|
000396  f5b57f9f          CMP      r5,#0x13e
00039a  d805              BHI      |L1.936|
;;;327      {
;;;328          
;;;329          //if((GPIO_ADS7843_INT_VALID) && distence(touchPoint.x,xScreen) && distence(touchPoint.y,yScreen))
;;;330          //{  
;;;331          	
;;;332    		touchPoint.x = xScreen;
00039c  4805              LDR      r0,|L1.948|
00039e  6004              STR      r4,[r0,#0]  ; touchPoint
;;;333          	touchPoint.y = yScreen;
0003a0  6045              STR      r5,[r0,#4]  ; touchPoint
;;;334    	  	touchPoint.flag =1;
0003a2  2001              MOVS     r0,#1
0003a4  4903              LDR      r1,|L1.948|
0003a6  7208              STRB     r0,[r1,#8]
                  |L1.936|
;;;335      	  //}
;;;336      }
;;;337        
;;;338    }
0003a8  bd7c              POP      {r2-r6,pc}
;;;339    /*=====================================================================*/
                          ENDP

0003aa  0000              DCW      0x0000
                  |L1.940|
                          DCD      0x40010c00
                  |L1.944|
                          DCD      0x40012000
                  |L1.948|
                          DCD      touchPoint

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  touchPoint
                          %        12
